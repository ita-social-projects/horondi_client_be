const { setupApp } = require('../helper-functions');
const { INVALID_PERMISSIONS } = require('../../error-messages/user.messages');

const { loginUser, deleteUser } = require('../user/user.helper');

const {
  CERTIFICATE_NOT_FOUND,
  CERTIFICATE_IS_ACTIVE,
} = require('../../error-messages/certificate.messages');

const {
  addCertificate,
  deleteCertificate,
  generateCertificate,
  getAllCertificates,
  getCertificateById,
  registerUser,
  updateCertificate,
} = require('./certificate.helper');
const { newCertificateInputData, newUser } = require('./certificate.variables');

let operations;
let certificateId;
let certificateName;
let certificateNullOwnerId;
let certificateNullOwnerEmail;
let certificateNullOwnerName;
let userId;

describe('Test behaviour of USER with role=user', () => {
  beforeAll(async () => {
    operations = await setupApp();

    const certificateNullOwner = await generateCertificate(
      { value: 1000 },
      operations
    );
    certificateNullOwnerId = certificateNullOwner._id;
    certificateNullOwnerEmail = certificateNullOwner.email;
    certificateNullOwnerName = certificateNullOwner.name;

    await registerUser(newUser, operations);

    const {
      data: { loginUser: userObject },
    } = await loginUser(newUser.email, newUser.password, false, operations);
    userObject.banned = { blockPeriod: '0' };
    userId = userObject._id;

    operations = await setupApp(userObject);
  });

  it('#1. User with role=user can generate certificate', async () => {
    const result = await generateCertificate(
      newCertificateInputData,
      operations
    );
    certificateId = result._id;
    certificateName = result.name;

    expect(result).toHaveProperty('name');
  });

  it('#2. User can add certificate that was bought offilne', async () => {
    expect(certificateNullOwnerEmail).toBe(null);

    const result = await addCertificate(certificateNullOwnerName, operations);
    certificateId = result._id;

    expect(result.email).toBe(newUser.email);
  });

  it("#3. User can't remove his certificate", async () => {
    const result = await deleteCertificate(certificateId, operations);

    expect(result).toHaveProperty('message', INVALID_PERMISSIONS);
  });

  it('#4. User can see only certificates owned by him', async () => {
    const result = await getAllCertificates(operations);

    expect(result.count).toBe(2);
  });
});

describe('Admin restrictions and cleaning DB', () => {
  beforeAll(async () => {
    operations = await setupApp();
    await deleteUser(userId, operations);
  });

  it('#1. Admin can`t delete unused certificate', async () => {
    const result = await deleteCertificate(certificateId, operations);

    expect(result).toHaveProperty('message', CERTIFICATE_IS_ACTIVE);
  });

  it('#2. admin can`t use addCertificate method', async () => {
    const result = await addCertificate(certificateNullOwnerName, operations);

    expect(result).toHaveProperty('statusCode', 403);
  });

  it('#3. delete certificate generated by User', async () => {
    const updatedCertificate = await updateCertificate(
      certificateName,
      operations
    );
    certificateId = updatedCertificate._id;

    await deleteCertificate(certificateId, operations);

    const certificate = await getCertificateById(certificateId, operations);

    expect(certificate).toHaveProperty('message', CERTIFICATE_NOT_FOUND);
  });

  it('#4. delete certificate generated by Admin', async () => {
    const updatedCertificate = await updateCertificate(
      certificateNullOwnerName,
      operations
    );
    certificateNullOwnerId = updatedCertificate._id;

    await deleteCertificate(certificateNullOwnerId, operations);

    const certificate = await getCertificateById(
      certificateNullOwnerId,
      operations
    );

    expect(certificate).toHaveProperty('message', CERTIFICATE_NOT_FOUND);
  });
});
